// Copyright 2012. The Cryptogram Authors. BSD License.
// Author: tierney@cs.nyu.edu (Matt Tierney)

#include <cstring>
#include <iostream>
#include <set>
#include <vector>

#include "aesthete.h"
#include "array.h"
#include "boost/numeric/ublas/io.hpp"
#include "ecc_image.h"
#include "google/gflags.h"
#include "jpeg_codec.h"
#include "reentrant_rand.h"
#include "reed_solomon/rs_codec.h"

DEFINE_int32(quality, 95, "JPEG quality to use.");

namespace cryptogram {

const int ByteSize = 8;

void FillWithRandomData(uint8_t *data, size_t len) {
  for (unsigned int i = 0; i < len; i++) {
    uint8_t tmp = rand() % 256;
    std::cout << tmp << " ";
    data[i] = tmp;
  }
  std::cout << std::endl;
}

unsigned int CountErrors(const matrix<double>& matrix_a,
                         const matrix<double>& matrix_b,
                         int threshold) {
  CHECK_EQ(matrix_a.size1(), 4);
  CHECK_EQ(matrix_a.size2(), 4);
  CHECK_EQ(matrix_b.size1(), 4);
  CHECK_EQ(matrix_b.size2(), 4);

  matrix<unsigned char> diff = matrix_a - matrix_b;
  unsigned int nerrors = 0;
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      if (abs((int)(char)diff(i,j)) >= threshold) {
        nerrors++;
      }
    }
  }
  return nerrors;
}

// We will be given a sequence of 223 randomly-generated bytes. The bytes will
// then be ECC'd to produce a parity sequence of bytes. This produce is executed
// twice. These 510 bytes are concatenated. The result is then embedded into an
// array that is the JPEG'd. The JPEG is decompressed and decoded to two total
// transmissions, which each are 255 bytes (223 message byte and 32 parity
// bytes). We must compare the sequence of bytes.
class EccMessage {
 public:
  enum Position {
    FIRST = 0,
    SECOND,
  };

  EccMessage() {
    memset(bytes_, 0, sizeof(bytes_));
    memset(first_message_, 0, sizeof(first_message_));
    memset(first_parity_, 0, sizeof(first_parity_));
    memset(second_message_, 0, sizeof(second_message_));
    memset(second_parity_, 0, sizeof(second_parity_));
  }

  virtual ~EccMessage() {}

  void SetMessage(uint8_t *message, Position pos) {
    memcpy(bytes_ + (pos * kRs255_223TotalBytes),
           message,
           kRs255_223MessageBytes);
  }

  void SetParity(uint16_t *parity, Position pos) {
    std::cout << "SetParity: " << std::endl;
    for (int i = 0, pos_i = pos * kRs255_223TotalBytes;
         i < kParityArraySize;
         i++, pos_i += 1) {
      // Sanity check that the parity values, even though they are stored in
      // uint16_t have a size of one byte.
      assert(parity[i] % 256 == parity[i]);

      std::cout << kRs255_223MessageBytes + pos_i << " ";
      bytes_[kRs255_223MessageBytes + pos_i + 0] = parity[i] % kCharMax;
      bytes_[kRs255_223MessageBytes + pos_i + 1] = parity[i] / kCharMax;
    }
    std::cout << std::endl;
    std::cout << std::endl;
  }

  static void FillWithRandomData(uint8_t *data, size_t len) {
    // Assumes that the PRNG has already been seeded.
    std::cout << "FillWithRandomData:" << std::endl;
    for (unsigned int i = 0; i < len; i++) {
      unsigned char generated = rand() % 256;
      std::cout << (unsigned int)generated << " ";
      data[i] = generated;
    }
    std::cout << std::endl;
  }

  unsigned char *flatten() {
    std::cout << "First Message: " << sizeof(first_message_) << std::endl;
    memcpy(bytes_,
           first_message_,
           sizeof(first_message_));
    SetParity(first_parity_, FIRST);

    std::cout << "Second Message: " << kRs255_223MessageBytes << std::endl;
    memcpy(bytes_ + kRs255_223TotalBytes,
           first_message_,
           sizeof(second_message_));
    SetParity(first_parity_, SECOND);

    return bytes_;
  }

  unsigned char *bytes() { return bytes_; }

  uint8_t *first_message() { return first_message_; }
  uint16_t *first_parity() { return first_parity_; }

  uint8_t *second_message() { return second_message_; }
  uint16_t *second_parity() { return second_parity_; }

 private:
  unsigned char bytes_[2 * kRs255_223TotalBytes];

  uint8_t first_message_[kRs255_223MessageBytes];
  uint16_t first_parity_[kParityArraySize];
  uint8_t second_message_[kRs255_223MessageBytes];
  uint16_t second_parity_[kParityArraySize];
};

struct DiscreteValue {
  explicit DiscreteValue(double input) { data = input; }

  double data;
};

// These comparisons are constructed assuming a greater or descending order in
// the set. You must reverse DiscretizationCompare and upper_bound and the final
// greater-than comparison in order to convert this code into correct
// functionality for ascending ordered sets.
struct DiscretizationCompare {
  bool operator()(const DiscreteValue & left, const DiscreteValue & right) const {
    return left.data > right.data;
  }
};
typedef std::set<DiscreteValue,DiscretizationCompare> Discretizations;

Discretizations::iterator FindClosest(const Discretizations& data,
                                      const DiscreteValue& searchkey) {
  Discretizations::iterator upper = data.upper_bound(searchkey);
  if (upper == data.begin() || upper->data == searchkey.data) {
    return upper;
  }

  Discretizations::iterator lower = upper;
  --lower;
  if (upper == data.end() ||
      (searchkey.data - lower->data) > (upper->data - searchkey.data)) {
    return lower;
  }
  return upper;
}

void Foo() {
  std::vector<int> discretizations;
  discretizations.push_back(240);
  discretizations.push_back(208);
  discretizations.push_back(176);
  discretizations.push_back(144);
  discretizations.push_back(112);
  discretizations.push_back(80);
  discretizations.push_back(48);
  discretizations.push_back(16);

  Discretizations set_discretizations;
  set_discretizations.insert(DiscreteValue(240));
  set_discretizations.insert(DiscreteValue(208));
  set_discretizations.insert(DiscreteValue(176));
  set_discretizations.insert(DiscreteValue(144));
  set_discretizations.insert(DiscreteValue(112));
  set_discretizations.insert(DiscreteValue(80));
  set_discretizations.insert(DiscreteValue(48));
  set_discretizations.insert(DiscreteValue(16));

  int query = 240 - 16;
  std::cout << "CLOSEST VALUE: " << FindClosest(set_discretizations, DiscreteValue(query))->data << std::endl;
  std::cout << "INDEX: "
            << std::distance(set_discretizations.begin(),
                             FindClosest(set_discretizations, DiscreteValue(query)))
            << std::endl;

  srand(time(NULL));

  EccMessage ecc_msg;
  EccMessage::FillWithRandomData(ecc_msg.first_message(), kRs255_223MessageBytes);

  RsCodec rs_codec;
  rs_codec.Encode(ecc_msg.first_message(), ecc_msg.first_parity());

  std::cout << "Ecc Message Contents: " << std::endl;
  for (int i = 0; i < kRs255_223MessageBytes; i++) {
    std::cout << (int)ecc_msg.first_message()[i] << " ";
  }
  std::cout << std::endl;

  for (int i = 0; i < kParityArraySize; i++) {
    std::cout << ecc_msg.first_parity()[i] << " ";
  }
  std::cout << std::endl;
  std::cout << " / Ecc Message Contents: " << std::endl;

  std::cout << "Various parts: \n" << std::endl;
  unsigned char *output = ecc_msg.flatten();
  std::cout << "First Message: \n" << std::endl;
  for (int i = 0; i < kRs255_223MessageBytes; i++) {
    std::cout << (int)output[i] << " ";
  }
  std::cout << "\nFirst Parity: \n" << std::endl;
  for (int i = kRs255_223MessageBytes;
       i < kRs255_223MessageBytes + kRs255_223ParityBytes;
       i++) {
    std::cout << (int)output[i] << " ";
  }
  std::cout << std::endl;

  std::cout << "Second Message: \n" << std::endl;
  for (int i = kRs255_223TotalBytes;
       i < kRs255_223TotalBytes + kRs255_223MessageBytes;
       i++) {
    std::cout << (int)output[i] << " ";
  }
  std::cout << "\nSecond Parity: \n" << std::endl;
  for (int i = kRs255_223TotalBytes + kRs255_223MessageBytes;
       i < 2 * kRs255_223TotalBytes;
       i++) {
    std::cout << (int)output[i] << " ";
  }
  std::cout << std::endl;

  // Now we have all of the values set for embedding into a JPEG.
  unsigned char *input_bytes = output;
  array<unsigned char> image(kBlocksWide * kPixelDimPerBlock * kCharsPerPixel,
                             kBlocksHigh * kPixelDimPerBlock);
  std::cout << "\nWrite MRs" << std::endl;
  const int kMatrixStrBytes = 6;
  for (int image_h = 0; image_h < kBlocksHigh; image_h++) {
    for (int image_w = 0; image_w < kBlocksWide; image_w++) {
      MatrixRepresentation mr;
      mr.InitFromString(input_bytes +
                        (image_h * kBlocksWide + (kMatrixStrBytes * image_w)));

      std::string tmp(mr.ToString());
      for (unsigned int i = 0; i < tmp.size(); i++) {
        std::cout << (unsigned int)(unsigned char)tmp[i] << " ";
      }

      std::vector<int> matrix_entries;
      mr.ToInts(&matrix_entries);

      image.FillBlockFromInts(matrix_entries, discretizations, image_h, image_w);
    }
  }
  std::cout << std::endl;

  // Prepare the matrices so that they are able to hold the values for the code.
  array<matrix<unsigned char> *> blocks(kBlocksWide, kBlocksHigh);
  array<matrix<double> *> aes_blocks(kBlocksWide, kBlocksHigh);
  for (int high = 0; high < kBlocksHigh; high++) {
    for (int wide = 0; wide < kBlocksWide; wide++) {
      blocks(wide, high) = new matrix<unsigned char>(8, 8);
      image.FillMatrixFromBlock(high, wide, blocks(wide, high));

      aes_blocks(wide, high) = new matrix<double>(4, 4);
      cryptogram::AverageAestheteBlocks(*blocks(wide, high), aes_blocks(wide, high));
    }
  }

  // array @image is prepared with the all of the JPEG color space information.
  vector<unsigned char> output_jpeg;
  assert(gfx::JPEGCodec::Encode(image.data,
                                gfx::JPEGCodec::FORMAT_RGB,
                                kBlocksWide * kPixelDimPerBlock,
                                kBlocksHigh * kPixelDimPerBlock,
                                kBlocksWide * kPixelDimPerBlock * kCharsPerPixel,
                                FLAGS_quality,
                                &output_jpeg));

  std::string output_bytes(output_jpeg.begin(), output_jpeg.end());
  std::cerr << output_bytes << std::endl;
  std::cout << std::endl;

  vector<unsigned char> decoded;
  int width = 0, height = 0;
  assert(gfx::JPEGCodec::Decode(&output_jpeg[0],
                                output_jpeg.size(),
                                gfx::JPEGCodec::FORMAT_RGB,
                                &decoded,
                                &width, &height));
  std::cout << "Decompressed image dimensions. Width: " << width
            << " Height: " << height << std::endl;
  std::cout << "Length of decompressed vector: "  << decoded.size() << std::endl;
  std::cout << "Width * 3 = " << width * 3 << std::endl;

  std::cout << "The Decoded Matrices:" << std::endl;
  array<matrix<unsigned char> *> decoded_blocks(kBlocksWide, kBlocksHigh);
  array<matrix<double> *> decoded_aes(kBlocksWide, kBlocksHigh);
  for (int high = 0; high < kBlocksHigh; high++) {
    for (int wide = 0; wide < kBlocksWide; wide++) {
      decoded_blocks(wide, high) = new matrix<unsigned char>(8, 8);
      // For each block, we want to be sure to capture the exact 64 pixel values
      // of that block.
      std::cout << "High: " << high << " Wide: " << wide << std::endl;
      for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
          int idx = (((high * kPixelDimPerBlock) + i) * (kBlocksWide * kPixelDimPerBlock * 3)) +
              ((wide * 3 * kPixelDimPerBlock) + (3 * j));
          std::cout << idx << " ";
          (*decoded_blocks(wide, high))(i, j) = decoded[idx];
        }
        std::cout << std::endl;
      }
      std::cout << std::endl;
      std::cout << std::endl;

      decoded_aes(wide, high) = new matrix<double>(4, 4);
      cryptogram::AverageAestheteBlocks(*decoded_blocks(wide, high),
                                        decoded_aes(wide, high));

    }
  }
  std::cout << std::endl;

  std::cout << "ENCODE: " << *aes_blocks(0,0) << std::endl;
  std::cout << "DECODE: " << *decoded_aes(0,0) << std::endl;
  std::cout << "NERROR: "
            << CountErrors(*aes_blocks(0,0), *decoded_aes(0,0), 16) << std::endl;

  for (int block_h = 0; block_h < 2; block_h++) {
    for (int block_w = 0; block_w < 8; block_w++) {
      matrix<double> *decoded_mat = decoded_aes(block_w, block_h);
      vector<int> decoded_ints;
      for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
          double val = (*decoded_mat)(i,j);
          int idx = std::distance(
              set_discretizations.begin(),
              FindClosest(set_discretizations, DiscreteValue(val)));
          decoded_ints.push_back(idx);
        }
      }
      MatrixRepresentation mat_rep;
      mat_rep.InitFromInts(decoded_ints);
      std::string final(mat_rep.ToString());
      CHECK_EQ(final.size(), 6);

      for (unsigned int i = 0; i < final.size(); i++) {
        std::cout << (int)(unsigned char)final[i] << " ";
      }
    }
  }
  std::cout << std::endl;

  // for (int height = 0; height < kBlocksHigh * kPixelDimPerBlock; height++) {
  //   for (int width = 0;
  //        width < kBlocksWide * kPixelDimPerBlock * kCharsPerPixel;
  //        width += kCharsPerPixel) {

  //     std::cout <<
  //         (int)image.data[
  //             height * kBlocksWide * kPixelDimPerBlock * kCharsPerPixel +
  //             width] << " ";
  //   }
  //   std::cout << std::endl;
  // }
}

} // namespace cryptogram

int main(int argc, char** argv) {
  google::ParseCommandLineFlags(&argc, &argv, false);
  cryptogram::Foo();

  return 0;
}
